[[{"l":"Welcome"}],[{"l":"Heap"},{"l":"fastbin-attack"},{"l":"Environment setup","p":["We are given the loader because there may be inconsistencies with the given libc and the system loader:","How do we bind the given loader and libc to the binary?","Fastest way: set the LD_PRELOAD environmental variable:","This solution uses system's loader.","To use both a different loader and a different library:","Most sofisticated way:","NixOS/patchelf: A small utility to modify the dynamic linker and RPATH of ELF executables (github.com)","To check which library a binary (./binary) we can use ldd ./binary.","If we run fastbin-attack with the 1st method we get a SEGFAULT, because we need also the loader. Also the following:","goes in SEGFAULT."]},{"l":"note on Ghidra pseudo C readability","p":["While exploring the pseudo C generated by Ghidra, we notice that some pieces of code are very hard to read, like disassembled while loops:","Since we are incresing the size of the single item, we need to decrease the number of array cells ( 1600*1=200*8). Result:"]},{"l":"What does it do","p":["A problem with free_entry","A problem with read_entry","After retyping the structure used by the binary, we get the following code for the write_entry function:","Basically the binary manipulates lists that have the following structure:","Given the address of a certain instruction in a disassembled binary, for example we can call it ADDR, we can still put a breakpoint in it:","how to put breakpoints in PIE binaries","It prints the entries variable after checking if the pointer is valid, but it does not check if the pointer has been freed. This is a memory leak. If you are wondering what that check should look like, this is the relevent snippet from the write_entry function:","more improvements on disassembled code readability","Note: entries is a global variable.","Pointer to return","Same as the other function: there is no check in place. We can free a chunk more than once. This means that we can basically print everything we want, which means that we can also leak the address of libc.","space","The check is performed against the state list that was introduced before.","The read_entry function has a security vulnerability:","Then we have another list that contains zero or one depending if the pointer contained in the first column is valid or not. Actually we have no second list, retyping in Ghidra fixed that for us. It allows us to allocate, write and free some text by using the heap.","This probably means that size actually is not a long(8 bytes), but it is an int(4 bytes). If we edit the structure according to this, it would have a char* and two int. New pseudo code of the same function:","Which is actually readable.","Which is much better if you ask me. Still something is wrong:"]},{"l":"The exploit in theory","p":["vulnerability: read_entry, can be used to leak stuff.","vulnerability: free_entry, we can free more than once chunks -> fastbin attack to make malloc allocate something in memory: the address of system() into either __free_hook or __malloc_hook.","More specifically when overwriting __free_hook we overwrite it with system and we pass /bin/sh to it. Instead when we overwrite __malloc_hook we use one_gadget since the parameter of the malloc is a number, not a string."]},{"l":"The exploit in practice","p":["alloc","And for reading and freeing:","Assuming that the parent folder containing all the needed files is called fa.","By allocating two chunks and freeing both of them, and again the first one, we will get a loop: chunk_1 points to chunk_2 and vice versa. Then","free_entry","If we do not find those bytes we can search elsewhere, for example near __malloc_hook.","Now that we can interact easily with the functions we can build the actual exploit:","Part 1: leaking libc address","Part 2: exploiting __free_hook __malloc_hook to spawn a shell","read_entry","Same for writing chunks:","simplifying the process","So, for example:","Still the program crashes because the malloc realizes that there's a mismatch with the size of the bin. We need to find some bytes not zeroed that are located before our target and try to match the size with those bytes, since they will be our new size for the chunk.","Then we take the address of that cell, we compute its offset, and put it in our script in place of __malloc_hook. Full exploit:","This happens because when we have only one chunk it will contain a random libc address, from which we can compute the address of the base of the libc. To find the offset we will use vmmap in gdb.","To change loader and library with pwntools (if we do not want to use the patched binary):","To simplify the work we will build functions in python to interact with the functions of the binary, which are:","We find that before __malloc_hook we have an address, but we know that after translating it to decimal it would be a gigantic number. We could exploit the alignment to take only part of it. For example we can go from 0x7ffff7... to 0x7f. To align we just add some bytes to the address of the cell to 'cut' its content according to our needs.","We need to leak libc, how do we do it? We allocate a small bin and free it, since after the free it will contain an address to a location which is is located into libc:","We will also need to parse the index which gets printed by the function:","Will result in 0x4141414141414141 becoming ?. Now we can put the address of __free_hook in its place.","write_entry"]},{"l":"playground"},{"i":"what-does-it-do-1","l":"What does it do","p":["It has only the main function which encompasses all the functionality. There are some nested loops that executes the following functionalities:","Basically it can:","Allocate a chunk of size n and return its address","Free a chunk, given its address p","Show the content of a chunk given p. By default it shows the first 8 bytes of data, unless a size n is specified.","Write some data into a chunk, given p.","There are some obvious vulnerabilities: for e.g. the chunk freeing is achieved without checking if the chunk is allocated or not, which could be used as an attack surface to carry a fast bin attack."]},{"l":"libc version","p":["A note about libc version: the program is using libc version 2.27 which incorporates a backport of the tcache key."]},{"l":"The exploit","p":["Here's what we need to do in order to exploit this binary:","Set to zero min_heap","Overwrite max_heap with a high value","Overwrite __malloc_hook with the magic gadget.","Note: min_heap and max_heap are two global variables on which a sort of boundary check is performed before working with the heap.","Setting min_heap to zero","We need to exploit the presence of the key in the tcache, since it allows us to overwrite any DWORD with zeros. Here's an example:","We can see that the program segfaulted because it tried to allocate 0x4141414141414141."]},{"l":"Note about one_gadget","p":["If we use the following flag: --level 1 when running one_gadget it will find a lot more gadgets."]},{"l":"pkm"},{"l":"A recall on the heap","p":["Allocated chunk","Free chunk","Note about gdb ptype command","ptype is a gdb command that allows to print variables of binaries that include symbols. For example in this binary we have the pkm variable, which is a struct. Thanks to that command we can print it and implement it in Ghidra for much easier code readability:","More on that:","ptype typename Print a description of data type typename. typename may be the name of a type, or for C code it may have the form class class-name', struct struct-tag', union union-tag' or enum enum-tag'.","Some informations about the heap management","If we try to allocate a new pokemon, and to rename it, we get the following heap configuration:","As we can see the chunk 0x101 bytes big is the chunk containing the pokemon, since it is allocated with a malloc(0xf8). The 0x21 chunk instead is the chunk allocated to read from stdin the pokemon name, since the get_string function allocates a chunk of arbitrary size, and I passed to it len('pikachu'). Content of pokemon in the heap:","Note that the chunk, as said before, is 257 bytes long, which is 32 WORDS. From 0x405100 and on we have another chunk, which in this case is the one containing the string which represents the pokemon name, and then we have the top chunk.","As for the content itself, we've got the statistics, which is decimal values look like this:","And then there's the pointer to the pokemon name, which is 0x405110. As for the second chunk we've got:","Which makes sense, since its 0x21 bytes long, which is 4 WORDS long."]},{"l":"Exploit idea","p":["We need to put in place a null byte poisoning exploit, which can be achieved trough the function used to assign names to pokemons:","To bypass the null byte overflow mitigation we need to exploit the rename_pokemon function, and fill a buffer which should contain a pokemon name with fake previous sizes. This is the function that calls get_string:","Where UNKNOWN is a global variable containing an address to the 'PKM' hardcoded string. This means that we can avoid to free a chunk if we previously wrote that in it."]},{"l":"How to perform the null byte poisoning","p":["If we create two pokemon and allocate two chunks of 0x200, that's the situation on the heap:","Let's call those chunk as follows:","Chunk 1: first chunk in the heap, it's pokemon 1","Chunk 2: second chunk, it's pokemon 2","Chunk 3: third chunk, it corresponds to pokemon 1 name","Chunk 4: third chunk, it corresponds to pokemon 2 name","Let's remember that the vulnerable function is the one that allocates the chunks of arbitrary length, which is the one we used to allocate the two 0x200 chunks. here's their content:","In the last row we have the header of the following chunk. As for the chunk at 0x405200, we have the usual structure:","Now, if we delete the first pokemon (chunk 1), we free both chunk 1 and chunk 3, since the binary will delete both the chunk containing the pokemon itself, and the chunk containing its name. We end up in this situation:","That's needed to trigger the null byte: in fact if we allocate again pokemon 1 and its name, we should get two identical sized chunks in the same spots as before, but the allocation of the chunk representing the pokemon name (chunk 3) would result in a null byte overflow into the name of pokemon 2 (chunk 4), which is immediatly after."]},{"l":"After executing the poisoning","p":["This is the script stdout that led to the heap setup below:","As you can see from 0x4056b0, if we do the heap command in gdb, it does not report the overlapped chunk which we get printed when we manually print heap addresses. Looks like we managed to correctly overflow and allocate two overlapping chunks. Now we can exploit that to carry the attack."]},{"i":"and-now","l":"And now?","p":["Basically up to now we just did things to trick malloc into giving us two chunks allocated and overlapping. Now we can actuate the exploit, which consists in replacing the function pointer of some move of a pokemon (chunk B2) with our exploit to get rce. We can do that by writing a target address in the overlapped chunk resulting from the null byte overflow. The binary helps us because each pkm struct has an array of function pointer which gets called by a function of the binary. So, to recap:","We perform the null byte exploit;","We use the overlapping chunk to write an address of interest in the moves array of the overlapped pokemon;","We call the function which executes the code at the given address to gain RCE.","We could write a one_gadget address, or somethigs else. In my case one_gadget was not working, so I wrote the following into the overlapped pokemon:","With binsh written in the chunk header, since by checking with gdb I saw that the argument passed to the address called during the fight_pkm was in the beginning of its chunk. Problem is, first of all we need to leak an address belonging to libc... This can be done via some symbols already resolved and present in the GOT, since the binary is not PIE. If we exploit the overlapping chunks to put an adress of the GOT into one of the overlapped pokemon chunk, and in particular into the name field of the pkm struct, we can print a libc runtime address. Code for this:","So we have a two stage exploit:","Script's stdout of the exploit in action:"]}],[{"l":"Packer"},{"l":"john","p":["As we know a packer is a type of malware that has an encrypted payload in order to avoid detection during static analysis. At runtime the malicious portion of the code is unpacked, and execute. This means that we need to look for some procedure that manipulates the .text section of the executable. From Unpacking Redaman Malware & Basics of Self-Injection Packers - ft. OALabs (liveoverflow.com):","Self-Injection is just one of the techniques used by malware authors for obfuscation, there are many other techniques like Process Injection(or Process Hollowing), Classic DLL Injection and Thread Execution Hijacking. There are a few different techniques for Self-Injection itself, but a common technique is to first unpack a small stub in-memory, it transfers the execution to the stub, the stub code then changes the permission of a section in the process, write the malicious code into those sections and transfer the execution back to the overwritten sections of the PE file.","We have something similare here:","The first argument of the mprotect is the address in memory from which we want to start changing permissions. The length is 4096 bytes. This probably means that the malicious code segment is located at param_1. By looking at the code at runtime, we can see that the address on which the mprotect is called is probably 0x804970e. Also it looks like it ends at 0x804990e. This means that it is located in this memory page:","which is also the only executable page of the .text section. This should be the code we want to examine to find the correct key for this binary:"]},{"l":"Notes from lesson","p":["Basically I was almost right about what was happening here. We have that the main is calling an unpacking routine, which is the unpack function above. The num parameter is a counter for a loop:","The counter is likely the size of the function to unpack. Note that the key used to decrypt the function depends on the address of the function itself.","We looked at the unpacking routine, but we're still missing the main part."]},{"i":"where-do-we-start","l":"Where do we start?","p":["We have two approaches:","Static: Since we understand the unpacking routine we can build an unpacker and look at it with ghidra.","Dynamic: we could run the binary and use ghidra to look at the unpacked running code, or we can dump the memory of the running binary and look at it."]},{"l":"Dynamic approach","p":["We'll break at the unpack function with gdb:","Ok up until now I was on the right track. My problem here was that I have no idea on how to read those assembly instructions...","The problem is that what we're looking at are packed instructions. If we break at the following line:","And we print the same memory cells we'll see the real code used to get the key!","Ok this makes sense: push ebp is how an actual disassembled function starts. Note that we have another function call:","Note that this could be another packer... Actually its the address of the unpack function. So we're calling another function trough the unpacker. Here's the new function:","If we look at the code with gdb:","We've got a call to the strstr function, and another call to the packer.","From this behaviour we unedrstand that the check on the flag is performed incrementally by calling unpack and the pack on some code, and so on. This means that we'll not have a point in time in which during execution the binary is completely unpacked. Extracting the unpacked code dynamically can be very time consuming, which means that a more efficient method would be to write a script that reverse engineer the packing algorithm, which then can be used to create a binary containing an unpacked payload. This is what the static approach does in a nutshell."]},{"i":"#","p":["Let's reverse engineer the packer with python:","This gives us a decent unpacked main:","We need to repeat this to unpack every function used to create the flag. The first three, as already seen, are respectively checks on the prefix ( flag{}), the suffix (}) and the type of characters of the flag (must be ascii). The last one is a check on the flag length (== 33). As for the other function we have the following structure:","Where the indented functions are calls that are made inside the outer ones. The first function determines the first 6 characters of the flag, which are 'packer'. We are still missing 21 characters, which are originated from FUN_080495e4 and FUN_08049546."]},{"l":"FUN_080496ab","p":["After unpacking we get:","Ok looks like there's another function to unpack: FUN_08049385, which becomes:","Which we can either reverse engineer with z3, or by looking at which characters are outputed in registers by using gdb (again dynamic approach). After reverse engineering this we'll get that the first part of the flag is flag{packer. Since the flag is 33 chars long, we are still missing 21."]},{"i":"fun-080495e4","l":"FUN_080495e4","p":["Looks like we need to reverse engineer this:","WTF is this? From a first look it seems like we're preparing local_7c and then we're comparing its content with the flag passed by the user using FUN_0804945e. If for some reason the comparison does not go well the function is exited. More specifically it looks like we're comparing each even character of local_7c and its successor with every character of the user input. This is the code that is doing the comparison:","First of all, this is the content of local_7c:","Which is not something that really makes sense translated in ascii. Actually neither the content of FUN_0804945e makes sense, really. If fact I was so done that I tried to bruteforce the checks. Basically, we know that the return value of FUN_0804945e must be 1. This means that we can script the execution with a gdbinit and try every possible characters for every position of the flag checked by the function to find what we need.","Ok now we know that the flag up to now is: flag{packer-4a3-1337 something }, where the missing part is 12 characters long."]},{"l":"FUN_08049546","p":["Ok we're still missing 20 characters, identified by this function:","After fixing the function signature with Ghidra it becomes:","Ok this looks easy. index starts from zero. Every function call its incremented by one. The check performed every call compares index+22 against 33, which means that we'll have 11 loop iterations. For evey iteration the character at index+20 of the flag is XORed with key and compared with its follower. Since the XOR is invertible, I think that we can reverse the process to get back the original characters. Using z3:","And with this we should be all set."]}],[{"l":"Reversing"},{"l":"revmem","p":["strace","strace is a diagnostic, debugging and instructional userspace utility for Linux. It is used to monitor and tamper with interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state.","ltrace","ltrace is a library call tracer and it is primarily used to trace calls made by programs to library functions. It can also trace system calls and signals, like strace."]},{"l":"A first approach","p":["Reversing challenge, meaning that we have just the binary and no remote connection needed. We just need to find the correct output that will make our binary print the flag. In this case we can start launching the binary with some random input to check its behaviour:","Ok, now lets strace it:","Not useful at all."]},{"l":"Actually is way easier than it looks like","p":["Now lets try ltrace on it:","Well...","This is happening because of this line of code:","From which we can see that the program is taking the flag which is hardcoded in memory.","From this snippet of code we can see that the flag is put in memory by a malloc after being obtained by XORing the encoded version of the flag. Because of the strcmp with the flag in memory and our input we can see the flag in clear with ltrace."]},{"l":"revmemp","p":["Very similar to revmem. Both strace and ltrace outputs are not very useful in this case. We can try to debug the application when the strcmp between the user input and the flag gets executed. From the disassembler:","Which corresponds to:","If we try to put a breakpoint there and to debug it:","Turns out we can't debug it with gdb:","Rip. This is a special function called INIT function, which is called before the begin of the main, which means that they are kind of hidden. Good way to find them: looking at which text output they prints, and search for it into Ghidra, or run strings on the binary","Can we stop the binary from escaping that check? Yes, we just need to patch the binary: we could, for example, replace the exit(-1) with tops to avoid this check altogether.","Still, we have another problem. The following function gets called multiple time during execution:","It basicaly checks if the first and second symbols of entry are breakpoints ( 0xcc). It basically avoids the user from using them."]},{"i":"how-to-patch-the-binary-xxd-the-hard-way","l":"How to patch the binary (xxd, the hard way)","p":["We'll be using vim. First of all open the binary: vim ./revmemnp. then input the following:","this gives us hex dump of the binary. Then we need to search for the byte codes of the instruction we want to replace. To search in vim we use the forward slash command. So, we want to replace the exit in the debugger avoider function to be a bunch of nop. So we'll first search for its first opcode:","Then press enter, and keep pressing n until we find our function:","Then we can use I to enter intert mode, overwrite it with pops (note that it is made up of 5 opcodes, which means we need 5 nops), and pass :%!xdd -r and :wq to save and exit. Or you could just use a gui hex editor, it works either way."]},{"l":"The exploit","p":["Basically we just need to overwrite both checks, the one which prevents us from setting a breakpoint, and the one that checks if we have gdb attached. Once the binary has been patched to remove the exit, we just start the binary with gdb, set a breakpoint in the strcmp, and then we can just see the flag in clear as argument of the strcmp:"]},{"l":"keycheck_baby","p":["In this challenge we have to reverse engineer a key encryption algorithm divided in two steps. We have the key which is split in two and encrypted differently using two loops."]},{"i":"pt1","l":"Pt.1","p":["This first loop XORs the key with characters from the string babuzz% 6 (modulo), which is the length of the string itself. Easy reverse, since we have the result of the XOR, which is the magic0 variable and we can just XOR the two to get past it (since the XOR is an invertible function):"]},{"i":"pt2","l":"Pt.2","p":["As for the second one:","We have a CBC encryption algorithm:","Cipher block chaining (CBC) is a mode of operation for a block cipher-- one in which a sequence of bits are encrypted as a single unit, or block, with a cipher key applied to the entire block. Cipher block chaining uses what is known as an initialization vector ( IV) of a certain length.","Implemented as such:","Note: in both loops the label LAB_00101487 take the instruction pointer to the end of the main, making the program exit. To reverse this we need an equation system as such:","Where IV is the initialization vector. This can be implemented in python as follows:","In the code above p_{i} are characters of the flag, while c_{i} are characters of magic1."]},{"l":"crackme","p":["Another easy reversing challenge, in this case we have a XOR cypher:","Solution:"]}],[{"l":"ROP"},{"i":"ropasaurusrex-32--bit-rop-chain","l":"ropasaurusrex (32- bit ROP chain)","p":["main","first_func()"]},{"i":"what-do-we-do","l":"what do we do?","p":["We have an overflow but we cannot perform a ROP exploit since we don't know where libc is in memory. Since we cannot print out the stack, we could exploit the GOT table to leak the address of system. Since the binary is not PIE, and the momry addresses of the code are not randomized at runtime, the GOT table has a permanent address that can be found with Ghidra. From the previous screenshot we can see the address of read: 804961c, and also the address of write. Those two functions alone are enough to read and print to screen the content of the file containing the flag.","how did we find the address of write inside the library?","We search write into Ghidra ( ctrl+shift+e) and we look for a jmp into the GOT that has an EXTERNAL::write parameter. Another way of doing that is using objdump and looking for write@plt:","Note that founding addresses of GOT is even easier in gdb:"]},{"l":"cyclic","p":["To check how deep are we in the stack we can use pwn cyclic -n 4 200 | ./ropasaurusrex which generates a pattern of 4 bytes, 200 chars long (since we are in a 32 bit environment, otherwise we would need a 8 bytes pattern). Then we check with gdb what section of the pattern gets into the instruction pointer (for e.g. gdb would print Invalid address at 0x6261616b), and then we can actually see how long must be our padding, by running:"]},{"l":"leaking libc","p":["Since the binary is x86, we need to put call arguments on the stack. We need the following stack layout:","Before / After","...","sEBP/ junk","sEIP/ write in PLT( what we want to execute)","Frame of caller / cleaner gadget (cleans up the next three cells and puts a ret in order to jump at the address that follows the three stack cells just cleared, which is the address of the main","Frame of caller / arg #1 (1st argument of what we want to execute, the fd of the write target)","Frame of caller / arg #2 (2nd argument of what we want to execute, what we want to write to stdout)","Frame of caller / arg #3 (3rd argument of what we want to execute, how much to write)","Frame of caller / main address ( return address after that the gadget cleans the stack)","On top of the stack we have the pointer of the write, the return address ( CCCC, for now we do not need it), and its parameters. The code above, when assembled into shellcode and executed, will execute a write syscall, which will write to stdout the address of the write itself. How did we tell to the write what to print? We passed as argument in the stack (remember x86 calling convention, which unlike x64 uses the stack instead of the register for function arguments) the address of write in the GOT table, which at runtime corresponds to the address of the same function but in libc. This means that since we know the offset of the write inside the library, we can compute libc base to know the address of system, which is the function that we'll use to spawn a shell.","Note about cleaner gadgets","This gadget will remove the arguments that we put in the stack to correctly execute the call. It is necessary if we want to execute a ROP chain."]},{"l":"Spawning a shell"},{"i":"emptyspaces-64-bit-rop-chain","l":"emptyspaces (64-bit ROP chain)","p":["It is statically linked binary, which means that libc is already located into the executable itself. That's why Ghidra lists lots of functions in the code. As a consequence, we can look for gadgets directly into the binary:","Moreover:","Actually this is weird because there's no canary in the binary.","Note: if the program crashes it is useful to do a dmesg to obtain additional info about it. As for security measures:"]},{"l":"the code","p":["main","empty:","Note: empty does not complicates things, since it just fills some space which would be padding anyway. If for example we fill the buffer with 64 'A' characters, the stack would look like this:","sEBP is overwritten, but we do not need it anyway."]},{"l":"What to do","p":["We know that we can perform a buffer overflow, but still we need to leak and put on the stack the canary (if present), and execute at least two syscalls: one to read /bin/sh and put it in memory, the other one to execute execve(/bin/sh, 0, 0);. We also need to find some gadgets to setup the registers to run a syscall. Weirdly ropper won't find useful gadgets, while ROPgadgets works just fine.","Note that in order to do that we need to restart the execution from main, since the read only takes 137 bytes and our exploit is longer than that. Since the binary is not PIE, this is possible without leaking any address at runtime."]},{"l":"The exploit","p":["The payload is made up by some padding necessary to reach sEIP. Then there is a first payload which is used to call a read to put in the heap /bin/sh, then we'll pass the string to put it in memory (at an arbitrary address decided by us):","After the read the execution flow is redirected to the main. When the program executes again a similar exploit is performed again, this time calling an execve which is used to spawn a shell:","Source code:"]},{"l":"easyrop"},{"l":"Initial considerations","p":["64 bit statically linked binary: the calling convention needs us to use register to setup a call to execve to spawn a shell. This is the only way since the stack is NX:","And system is not present in the binary. We can perform buffer overflow by filling the stack exploiting the while loop in the main function. Ghidra disassembled code:","Basically we can fill up 8 bytes (1 cell) of the buffer in each loop iteration, since no array bound check is performed. Between the beginning of the array and seip there are 56 bytes."]},{"l":"The actual exploit","p":["...","* array[...] + 48","0 (read syscall code)","0 (stdin)","0x3b (execve syscall code)","8 (#bytes to read)","AFTER VULNERABLE READ","array[...]","Basically we want to perform a read to put '/bin/sh' in memory, and pass it as argument to the execve syscall in order to be able to spawn a shell.","BEFORE VULNERABLE READ","g1 address","g1 is a gadget that performs the following operations:","g2 address","g2:","g3 address","g3: syscall","global variable address (/bin/sh location)","junk","Note that:","padding","pointer to zero (rdx content)","pointer to zero (rsi content)","pop rdi, pop rsi, pop rdx, pop rax, ret","sebp","seip","syscall, nop, nop, pop rbp, ret","The newline character of /bin/sh\\x00 makes the syscall fail (it will return -1 in rax). Solution: pass the string with pwntools. Actual exploit:","This will be the structure of our exploit:","We need a syscall gadget that also performs a ret in order to be able to execute another syscall (execve /bin/sh) after the read."]}],[{"l":"Serialization"},{"l":"lolshop","p":["We wanto to exploit the restore function, since it has a vulnerability which can allow execution of non serialized malicious code. Ideally we would also like to exploit the getPicture function in products.php, since it has an hardcoded path into it. Note that it is also called into a toDict function.","To recap: we need to read the secret file. We have a compressed internal state variable, which we would like to decode. It is send back and forth via requests and it is encoded in base 64:","The result is a php serialized object. We can inject anything we want into it. We need another class / more than on class to get a print of the secret file present in the server's file system."]},{"l":"In a nutshell","p":["If we send a product instead of a state, the toDict of the product is going to be called. The output will contain the getPicture function, which will read from the filesystem the path we want, which will be the secret file. Code for that:","What do we put in the payload.php script? The quickest way to generate the PHP code is to use the php shell ( php -a):","In the first line we copied into the console all the class code from the website source code.","Note: HTTP status code 500 means internal serve error. It is good, since it means that there's something wrong that we can exploit."]},{"l":"free-as-in-beer","p":["We do not have any source code... We just have the url of the challenge, and some hints: we know that the flag is contained in the flag.php file, and that we'll probably find some exploitable code if we look carefully. In fact we can find some PHP source code in plain text:","I'm a bit of a novice in PHP, so let's look more carefully at what we're dealing with. Here's some notes:","Returns the portion of string specified by the offset and length parameters.","Calculates the MD5 hash of string using the » RSA Data Security, Inc. MD5 Message-Digest Algorithm, and returns that hash.","__FILE__ is a magic constant that gives you the filesystem path to the current .php file (the one that __FILE__ is in, not the one it's included by if it's an include.","REQUEST_URI: The URI which was given in order to access this page; for instance, '/index.html'.","header() is used to send a raw HTTP header. See the » HTTP/1.1 specification for more information on HTTP headers."]},{"l":"A first approach","p":["This is the exploitable part of the code, leaked in the html of the page:","PHP magic methods recall","Recall on magic methods such as __toString:","Magic methods are special methods which override PHP's default's action when certain actions are performed on an object.","Caution","All methods names starting with __ are reserved by PHP. Therefore, it is not recommended to use such method names unless overriding PHP's behavior.","...","The __toString() method allows a class to decide how it will react when it is treated like a string. For example, what echo $obj; will print.","Source: PHP: Magic Methods - Manual","To recap","Basically we need to serialize an instance of the GPLSourceBloater class with the source variable setted as flag.php. To achieve that we create the object, serialize it, and put it in the todos array. After that it's just a matter of sending a GET to the server with our custom cookie and the flag will be printed."]},{"l":"metactf","p":["More complex than free-as-in-beer. We have two classes: User and Challenge:","We can both download and upload user objects: those get serialized before being downloaded, and unserialized after being uploaded. Since the web app hasn't got any user input validation/sanitization, we can put everything we want into the user object.","About user objects","Here's what we get if we create a user and download its serialized object:","Which becomes:","Note about fetch_assoc()","It is used to fetch a result row as an associative array.","Magic methods in this challenge","__construct: If you create a __construct() function, PHP will automatically call this function when you create an object from a class.","__destruct: If you create a __destruct() function, PHP will automatically call this function at the end of the script. This is the method we'll exploit to leak the flag."]},{"i":"a-first-approach-1","l":"A first approach","p":["I tried downloading the default user object created by the website, changing the number of points and setting isAdmin to true:","Thanks to that I managed to print a test challenge in the homepage of the app Actually this is not true, as you'll see later on:","Name: Test Challenge","Desc: This is an enabled test challenge","Points: 100","The code above gets printed for every user, admin or not."]},{"l":"The solution","p":["Since in the code of the Challenge class we can execute arbitrary shell commands, we could try executing cat /flag.txt. First we need to instantiate a new object, which we did (Test Challenge). Then we need to delete it, which will call the __destruct() magic method, which will call the stop() function. If we previously set $c-stop_cmp = 'cat /flag.txt', we should be all set. Still we need a way to manipulate the object...","array_push()","array_push() treats array as a stack, and pushes the passed variables onto the end of array. The length of array increases by the number of variables pushed. Has the same effect as:","exec in PHP","command: The command that will be executed.","output: If the output argument is present, then the specified array will be filled with every line of output from the command. Trailing whitespace, such as \\n, is not included in this array. Note that if the array already contains some elements, exec() will append to the end of the array. If you do not want the function to append elements, call unset() on the array before passing it to exec().","result_code: If the result_code argument is present along with the output argument, then the return status of the executed command will be written to this variable.","To recap","We just needed to serialize a specially crafted Challenge object and to put it into the file that would be uploaded...","Then, after uploading this, we load index.php and we'll get:","User Backup file:","Load User","Stoping challenge!flag{nice_yuo_got_the_unserialize_flag!}"]},{"l":"metarace","p":["Same webapp as metactf, but different exploit: we need to registrate, login and get to the homepage before that the registration is finished. This is because at registration time the user is setted as non admin, which means that he cannot see all the challenges present in the database. If we are able to send a login request and to get the index.php faster than that, we'll be able to print what we need.","register.php","login.php","db.php","fix_user","get_admin()","get_challenges()","Quite straightforward: we setup two threads and we try to login and get to the home page of the website while the registration is still ongoing in order to be faster than the fix_user function, which would block access to the database."]}],[{"l":"Shellcode"},{"l":"backtoshell","p":["UNRECOVERED_JUMPTABLE= the compiler is guessing the presence of a jump table, but its not. Its just a buffer.","mmap: mmap= linux func that allocates memory regions","If the mmap address is zero, the address will be randomized. The other parameters says where to find the size of the data that will be allocated, and its permissions. The fd is used to load a file into memory. in mmap 7 means rwx.","read: read= linux syscall that reads bytes from file descriptors (for e.g. 0 is the fd of stdin). Example:","read(0, UNRECOVERED_JUMPTABLE, 0x200) reads from zero into the jump table for 0x200 bytes. Note that this info is obtainable trough man."]},{"l":"behaviour","p":["(*memory)(0,0,0,0,0,0) means: jump to memory. It means that the first six registers contain zeros when jumping. So basically this binary is creating a page in memory, reading user input into it, and then it jumps into it. We want to put some code in that page which when executed will helps us to spawn a shell."]},{"l":"Putting together the shellcode","p":["First of all we need a syscall:","syscall= way that programs use to interact with the kernel, in order for e.g. to r/w a file, send packets, use hw, etc. To execute syscalls, some registers get set up and the syscall is ran. The kernel knows which syscalls is going to be executed by the rax register content (for e.g. read has number 0x00).","To open a shell, we need the execve syscall, which has to be executed with /bin/sh as first parameter. In order to do that we will put 0x3b in the rax register, and a pointer to /bin/sh\\x00 into rdi.","Note: Since the code of the binary sets rsp to zero, when the program jumps to our shellcode and we push things on the stack, the execution fails. We first need to move the stack in the middle of the memory page allocated with memmap, and then we can execute our shellcode.","Note (zeros): that zeros in the exploits need to be avoided is the input is read with a scanf function.","Note (char array as sycall argument): We need to put a pointer to a zero to terminate the array of arguments of the execv function, which means that we need to put a pointer to a zero in the rsi register (since the function writes those registers in this order: rax, rdi, rsi).","Note (rax register): The rax register is usually used for function return values.","After flagging we can get the source code of the binary from the server:"]},{"i":"syscall-syscalr","l":"syscall, syscalr","p":["Here we need an auto modifying shellcode, since the only obstacle to executing our exploit is that we cannot give \\x0f or \\x05 in input to the read otherwise the program would exit:","The strategy here is to make the shell code increment the content of the instruction pointer. This means that when the code of the challenge is checked after the read, the incriminated bytes are not found, but when the shellcode is acually executed the final code will contain the opcodes for a syscall. Here's the assembly:","Here we make the code increment by 257 the last two bytes of itself:","And then when we get the assembled code:","We can manually swap the last two bytes:","This means that when the code will be run it will first pass the check, and then correct itself to execute syscall as last assembly instruction."]},{"l":"multistage","p":["Hint: the challenge name means that we'll probably need a two step exploit for some reason. In this case the problem is the following:","Which means that we need an exploit no longer than 20 bytes. The following is a valid (but still too long) shellcode:","Length: (26 bytes of shellcode +8 of /bin/sh\\x00) > 20.","Solution: execute another read, which reads more byte into the buffer global variable, in which we will put the execve call to spawn a shell:","Note: mov takes up a lot more bytes than xor.","We can also put 20 nop at the beginning of our shellcode instead of putting rax+20 in the rdx register, and try to shorten even more our shellcode:"]},{"l":"gimme3bytes","p":[":(","And then we need to execute the syscall with the relevant opcodes, which alone take up two bytes ( 0f 05). If we run the binary in gdb and we check the content of registers while the program jumps to our shellcode, we'll see the following configuration:","At first I tried to pass \\x90\\x0f\\x05, which is nop syscall. Technically it should work, but from man read we see that:","Note that rdx actually contains the address to the page in which our input goes, but since it will be interpreted as an integer representing how much we are going to read, it is more than fine! In fact gdb reports that the address is 0x7ffff7ff7000, which amounts to 140737354100736. I think its enough.","Note: we can send both shellcodes with one call of the send function.","Ok so we have a giant memory page allocated to which we put user controlled input into, and then we jump to it and execute it. This would be the simplest ctf ever, if it was not for the fact that we can only read three bytes into it.","On Linux, read() (and similar system calls) will transfer at most 0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually transferred. (This is true on both 32-bit and 64-bit systems.)","rax= 0","rax= 0x0","rdi= 0","rdi= 0x0","rdx= 0x7ffff7ff7000( how much do we want to read)","rdx= READ_LENGTH","rsi= 0x7ffff7ff7000( destination )","rsi= READ_CONTENT","Still, we can change rdx content with one byte!","The first thing that comes to mind while tackling this challenge is that we could try to execute another read, but still, how the f* ck would we do that with only 3 bytes of code? To execute a read, since we've got a 64 bit binary and the syscall calling convenction wants function parameters to be set up into registers, we'll need the following:","Then, after rdx has been properly set up, we can use two syscalls: the first, by using only three bytes, will be a read that will read the proper shellcode to which we'll jump right after the first call. Final exploit:","This really sucks.","Where 0x7ffff7ff7000 is the address of the input taken by the read. This means that we actually have all we need to correctly perform a read. In fact all the registers are correctly set to spawn another read at the time the program jumps to our input."]},{"i":"leakers-gonnaleak-aslr","l":"leakers, gonnaleak, aslr","p":["Note: I have put all those challenges in one chapter because they are really similar.","leakers code:","Note: The source code of the challenge is found in the server directory after obtaining the shell. We are given only the binary. This is true for every challenge.","To leak values from the stack we can exploit the fact that we have a read that puts uset input on the stack, but the size check performed is actually bigger than the buffer itself. Since later on the buffer content is displayed via a printf, which stops reading when it encounters a terminator, we have our exploit: the read does not put a terminator when it stops (for e.g. the scanf does), which means that we can overwrite null bytes that follows the buffer in the stack to leak stack content up to our canary.","To leak stack canary we can give in input to the read which fills the local buffer the following content:","To completely fill it and to overwrite the null bytes that makes up the padding of the canary. In fact the canary is located right after the local buffer in the stack:","Then the canary gets leaked by the printf:","And we can extract it with python:","Gonnaleak is similar, but one more step is required: we do not have a global buffer, which means that we cannot jump to a fixed address. The obvious solution is to l eak some sort of address from the stack which belongs to the frame of main, which we can use to jump to our local shellcode by doing some math on relative addressing. Full code below.","Regarding ASLR, we have to go one step further: we have PIE enabled, which means no more hardcoded global buffers. We also got NX, so no local buffer overflows. To solve this challenge we have to leak the address of the global buffer, which is executable, put there the shellcode and overwrite seip with its address. Source code of the challenge:"]}],[{"l":"Symbolic"},{"l":"pnrg","p":["Very simple program in theory: it takes 4 truly random bytes from /dev/random, it checks them agains user input: if they are equal, it prints the flag. Basically we need to recover those random bytes. In the middle of this we have some calls to functions called seedRand and genRandLong, which together with the name of the challenge can give us some hints about its nature:","Most pseudo-random number generators (PRNGs) are build on algorithms involving some kind of recursive method starting from a base value that is determined by an input called the \"seed\".","...","The purpose of the seed is to allow the user to \"lock\" the pseudo-random number generator, to allow replicable analysis. Some analysts like to set the seed using a true random-number generator (TRNG) which uses hardware inputs to generate an initial seed number, and then report this as a locked number. If the seed is set and reported by the original user then an auditor can repeat the analysis and obtain the same sequence of pseudo-random numbers as the original user. If the seed is not set then the algorithm will usually use some kind of default seed (e.g., from the system clock), and it will generally not be possible to replicate the randomisation.","There are various ways to solve the challenge, from symbolic analysis (the most sophisticated), to brute forcing (the simplest method).","From the Ghidra pseudocode we can deduce that local_1408 is the internal state of the algorithm. It is a structure that holds all of its internal data.","Note: the seed is 8 bytes long."]},{"l":"Symbolic execution method","p":["Basically we need to replicate the behaviour of the program using z3 to reconstruct the final output. main code:","What's the hard part here? We need to replicate the gen and seed function as they are in the binary.","Where to start? Let's look at genRandLong:","Ok, it looks a bit scary... A quick google search of the constants brings up the algorithm that is being implemented here: Marsenne Twister 19937 generator.","A pseudo-random number generator engine that produces unsigned integer numbers in the closed interval [0,2^{w}-1].","The algorithm used by this engine is optimized to compute large series of numbers (such as in Monte Carlo experiments) with an almost uniform distribution in the range.","The engine has an internal state sequence of n integer elements, which is filled with a pseudo-random series generated on construction or by calling member function seed.","The internal state sequence becomes the source for n elements: When the state is advanced (for example, in order to produce a new random number), the engine alters the state sequence by twisting the current value using xor mask a on a mix of bits determined by parameter r that come from that value and from a value m elements away (see operator() for details).","The random numbers produced are tempered versions of these twisted values. The tempering is a sequence of shift and xor operations defined by parameters u, d, s, b, t, c and l applied on the selected state value (see operator()).","The random numbers generated by mersenne_twister_engine have a period equivalent to the mersenne number 2^{(n-1)w}-1.","Note about IPython","If we want to execute some code in python and then manipulate its output manually or to play with it, we can append this at the end of the script:"]},{"l":"seedRand","p":["Let's start by converting m_seedRand in python:","Now, since state is an important structure in the original algorithm, it is better to initialize it as a class in our exploit:","Which means we can simplify the previous implementation:"]},{"l":"genRandLong","p":["Wtf is mag.3808? It a global variable 16 bytes big. The first 8 are null, while the remaining 8 are a hexadecimal value. Note also that its index is 1, which means that it is either 0 or 1 (ampersand of arity two is the bitwise AND operator). This translates in python as:","Actually this does not work:","Because it is a python integer and z3 does not know how to work with it. Solution: create a BitVecVal.","Python translation of the function :","Note that we need to fix variable length: if we multiply two 32 bit numbers, the output would be 64 bits long. We need to add an ampersand 0xffffffff after the multiplication.","Bruteforce approach","Recall: this code is a random number generator with a random seed. The challenge prints out the 1001 random number and it asks for the random seed. Up until now we saw constraint programming ( symbolic execution). We can also bruteforce it locally. It can be done two ways: by restarting every time the challenge binary, which can be costly, or by reimplementing the algorithm in another binary and launching this modified binary only one time.","Note: code without syscalls is faster.","Why are we able to reverse: from the same state we can always get the same output. The only random part of the algorithm is the seed."]},{"l":"prodkey","p":["We have a 30 characters long key that we have to guess to get the flag, which is stored remotely. To check the correctness of our input flag the binary calls a function called verify_key, which returns 1 if its correct, 0 otherwise.","More specifically this is the check implemented by verify_key:","As we can see we have a bunch of functions that have to not return zero in order fot the check to pass. We need z3 to reverse them. They are 16 (one for each hexadecimal cypher). Or we can use angr. Using z3 can be quite time consuming, since we have to rework all the checks functions to be compatible with z3's symbolic data types. Foe example check_01 would go from:","To:"]},{"l":"Race condition"},{"l":"aart","p":["Goal: register a user and login before that the restriction gets activated. This is the point of the race condition: we need to make the login happen before the registration is actually complete. More specifically, this is from register.php:","And this is from login.php:","And we need to make registration and login happen at the same time in order to be able to login before that INSERT into privs (userid, isRestricted) values ((select users.id from users where username='$username'), TRUE); gets executed."]},{"l":"Toolkit","p":["Best python library for handling HTTP requests, hands down. We'll use it for this challenge, since both the login and registration functions are POST requests. To look at requests we could use chrome developer tools or wireshark since HTTP requests are in clear."]},{"l":"Approach","p":["First approach: we can try making the registration and the login happen at the same time. This will not work:","Since the login is not fast enough. We need a multi-threading library.","The code above actually prints the flag.","Note: we need a new username for each attempt, which means that a random string generator as username would be a good choice to make the exploitation simpler."]}],[{"l":"XSS","p":["Some notes about CSP:","default-src directive serves as a fallback for the other CSP fetch directives. For each of the following directives that are absent, the user agent looks for the default-src directive and uses this value for it.","The script-src directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into script elements, but also things like inline script event handlers ( onclick) and XSLT stylesheets which can trigger script execution.","object-src 'none' Prevents fetching and executing plugin resources embedded using object, embed or applet tags. The most common example is Flash.","script-src nonce-{random} 'unsafe-inline' The nonce directive means that script elements will be allowed to execute only if they contain a nonce attribute matching the randomly-generated value which appears in the policy.","Note: In the presence of a CSP nonce the unsafe-inline directive will be ignored by modern browsers. Older browsers, which don't support nonces, will see unsafe-inline and allow inline scripts to execute.","script-src 'strict-dynamic' https: http:'strict-dynamic' allows the execution of scripts dynamically added to the page, as long as they were loaded by a safe, already-trusted script (see the specification).","Note: In the presence of 'strict-dynamic' the https: and http: whitelist entries will be ignored by modern browsers. Older browsers will allow the loading of scripts from any URL.","'unsafe-eval' allows the application to use the eval() JavaScript function. This reduces the protection against certain types of DOM-based XSS bugs, but makes it easier to adopt CSP. If your application doesn't use eval(), you can remove this keyword and have a safer policy. More on the eval function:"]},{"i":"recall-what-is-api-callback-and-why-are-we-using-it","l":"Recall: What is API callback and why are we using it?","p":["From Bypassing CSP by Abusing JSONP Endpoints | by Mazin Ahmed | Medium:","JSONP APIs normally works by having a parameter that sets a callback, so that users of the JSONP API can freely use the API according to their code. The GET parameter is reflected on the response in the 0 offset. This means that we basically control the start of the response body. JavaScript is a very dynamic language. It dynamically allows us to do many things we should not do, and are not supposed to do. Let’s use some of JavaScript magic to our side here. What if we enter:","alert(1);//","as our callback? If no proper sanitization is done on the JSONP endpoint, it will be reflected as the following:","alert(1);//{“name”: “Mazin”}","This is technically a correct JavaScript code! The syntax is correct as the rest of the response of commented out. JS engines would treat the data as a typical JavaScript code instead of a JSONP endpoint."]},{"l":"babycsp","p":["Valid JSONP belonging to *.google.com that we can use:","script src=https://accounts.google.com/o/oauth2/revoke?callback=alert(1337)/script","Since the CSP of the website is:"]},{"l":"The exploit","p":["We need a page that makes an HTTP req to reqbins, and that sends to it all the cookies. Then we use the XSS vulnerability on the website of the challenge to make the admin visit that webpage, and we should be all set. More specifically those are the steps to follow:","First we setup our requestbin and we copy its url","Then we execute a GET to the homepage of the challenge to create a session","We perform a POST to create the content on the webapp","Then we perform a GET to make the admin visit the url of our post. When loaded it will execute or javascript code, this performing the XSS attack which will send the admin's cookies to our request bin by performing a POST to it with the cookies encoded in the headers.","This is the javascript payload:","Where HOOK is the url of the request bin. Putting that in a post and sending it to the admin will allow us to send the session cookie of the admin, which contains the flag, to our bin embedded as request parameter."]},{"l":"csp","p":["Because of object-src 'none' we cannot use object, embed or applet tags.","We have user input escaping. More specifically, if I send this text:","This is what gets printed:","Which means that we only have ; ! - = {} (). Still, we have a vulnerability. In fact there's a specific field, which is the one that is used to add participant names to the event, which is not escaped. As such we can use it to carry our exploit."]},{"l":"First approach","p":["Now that we have some attack surface, I started trying some exploits.","First off, from Content Security Policy (CSP) Bypass - HackTricks:","Content-Security-Policy: script-src https://google.com 'unsafe-eval';","Working payload: script src=data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==/script","But that did not work:","Caricamento non riuscito per lo script con sorgente “data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==”..","This looked promising: script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337/script, but the GET request returns 404.","embed src='//ajax.googleapis.com/ajax/libs/yui/2.8.0r4/build/charts/assets/charts.swf?allowedDomain=\\})))}catch(e){alert(1337)}//' allowscriptaccess=always this would not work because this csp blocks embed tags.","This actually worked:","But this is tricky, because it basically executes the url and it puts the result as function argument, in this case we've got an alert, which means that the result of that google search will be printed as an alert by the browser.","This other one script src=https://www.google.com/tools/feedback/escalation-options?callback=alert(1337)/script actually does something, but from the look of it, its not useful: it just returns a GET with this body:"]},{"l":"Solution","p":["A bit disappointing, since I solved this with random code found on the internet. From CSP - Pentest Book (six2dez.com):","Note: the payload must be at most 255 characters long!"]},{"l":"strict-csp","p":["Here we've got a problem: we have a nonce implemented in the CSP. First thing off, I vaidated it with CSP Evaluator (csp-evaluator.withgoogle.com). From that we can see that we've got a problem derivating from the fact that base-uri is missing:","Missing base-uri allows the injection of base tags. They can be used to set the base URL for all relative (script) URLs to an attacker controlled domain. Can you set it to 'none' or 'self'?","And the same goes for require-trusted-types-for:","Consider requiring Trusted Types for scripts to lock down DOM XSS injection sinks. You can do this by adding \"require-trusted-types-for 'script'\" to your policy.","The exploit surface here is the require.js file. This is enough to solve the challenge:"]}]]